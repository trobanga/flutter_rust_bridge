"use strict";(self.webpackChunkflutter_rust_bridge=self.webpackChunkflutter_rust_bridge||[]).push([[4222],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),l=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(n),m=r,y=c["".concat(u,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(y,i(i({ref:t},p),{},{components:n})):a.createElement(y,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6563:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={},i="Automatic arbitrary Rust type",s={unversionedId:"guides/types/arbitrary/rust-auto-opaque",id:"guides/types/arbitrary/rust-auto-opaque",title:"Automatic arbitrary Rust type",description:"This feature, sometimes called RustAutoOpaque throughout the documentation,",source:"@site/docs/guides/types/arbitrary/rust-auto-opaque.md",sourceDirName:"guides/types/arbitrary",slug:"/guides/types/arbitrary/rust-auto-opaque",permalink:"/flutter_rust_bridge/guides/types/arbitrary/rust-auto-opaque",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/website/docs/guides/types/arbitrary/rust-auto-opaque.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Arbitrary types",permalink:"/flutter_rust_bridge/guides/types/arbitrary/"},next:{title:"Automatic arbitrary Dart type",permalink:"/flutter_rust_bridge/guides/types/arbitrary/dart-opaque"}},u={},l=[{value:"Example",id:"example",level:2},{value:"Use the underlying data in Dart",id:"use-the-underlying-data-in-dart",level:2},{value:"Ownership",id:"ownership",level:2},{value:"Dispose",id:"dispose",level:2},{value:"Force a non-opaque type to be opaque",id:"force-a-non-opaque-type-to-be-opaque",level:2},{value:"Implementation details",id:"implementation-details",level:2}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"automatic-arbitrary-rust-type"},"Automatic arbitrary Rust type"),(0,r.kt)("p",null,"This feature, sometimes called ",(0,r.kt)("inlineCode",{parentName:"p"},"RustAutoOpaque")," throughout the documentation,\nallows arbitrary Rust type to be used without manual intervention,\nby representing arbitrary Rust object as (smart) pointers in Dart."),(0,r.kt)("p",null,"Different from non-opaque types, opaque types are not copied/moved/reconstructed at all.\nFor example, if you pass around ",(0,r.kt)("inlineCode",{parentName:"p"},"RwLock<Mutex<ArbitraryData>")," in arguments and return values,\nyou will get the exact ",(0,r.kt)("em",{parentName:"p"},"same")," ",(0,r.kt)("inlineCode",{parentName:"p"},"RwLock<ArbitraryData>")," object."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Suppose you have a type that is not encodable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct MyNonEncodableType {\n    // e.g., a temporary directory, a file descriptor, a native resource, a lock, a channel, ...\n    sample_non_encodable_field: tempdir::TempDir,\n}\n")),(0,r.kt)("p",null,"Then you can have Rust functions and methods on it.\nMost, if not all, features of flutter_rust_bridge are supported,\nand here are a few examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn create() -> MyNonEncodableType { ... }\n\npub fn consume(obj: MyNonEncodableType) { ... }\n\npub fn borrow(obj: &MyNonEncodableType) { ... }\n\npub fn mutable_borrow(obj: &mut MyNonEncodableType) { ... }\n\nimpl MyNonEncodableType {\n    // Or `self`, `&mut self`\n    pub fn methods_on_it(&self) { ... }\n}\n")),(0,r.kt)("p",null,"They can be called in Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"var object = await create();\nawait borrow(object);\nawait mutable_borrow(object);\nawait consume(object);\n")),(0,r.kt)("h2",{id:"use-the-underlying-data-in-dart"},"Use the underlying data in Dart"),(0,r.kt)("p",null,'You might wonder, since the Dart side is just a "pointer",\nhow to use the underlying data in Dart?\nThe answer is through functions (and/or methods).'),(0,r.kt)("p",null,"In short,\njust imagine those fields are private (to Rust) - the ",(0,r.kt)("strong",{parentName:"p"},'"private fields" concept')," you use everyday\nto do encapsulation,\nthen write standard code."),(0,r.kt)("p",null,"For example, suppose we want to manipulate with the temporary directory object in the sample above,\nthen the rough code looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct MyTempDir {\n    dir: tempdir::TempDir,\n}\n\nimpl MyTempDir {\n    pub fn new() -> Self { ... }\n    \n    pub fn directory_path(&self) -> String {\n        self.dir.path()\n    }\n    \n    pub fn read_text(&self, filename: String) -> String {\n        fs::read_to_string(self.dir.path().join(filename))\n    }\n    \n    // ...\n}\n")),(0,r.kt)("p",null,"These methods can be called in Dart as if normal Dart functions (code sketch as below):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"var d = await MyTempDir.newMyTempDir();\nprint(await d.directoryPath());\nprint(await d.readText('a.txt'));\n")),(0,r.kt)("h2",{id:"ownership"},"Ownership"),(0,r.kt)("p",null,"As expected, the ",(0,r.kt)("inlineCode",{parentName:"p"},"MyNonEncodableType"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&MyNonEncodableType"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut MyNonEncodableType"),"\nmeans the standard Rust ownership things - owned, borrowed, mutable borrowed.\nFor example, in normal Rust, we cannot mutably borrow the same object twice at the same time.\nWhen doing so for ",(0,r.kt)("inlineCode",{parentName:"p"},"RustAutoOpaque")," objects, you will receive a runtime error."),(0,r.kt)("p",null,"In short, just write normal Rust code, and you are safe.\nAnything that violates Rust's model or safety will be caught and provide a runtime error,\ninstead of the dangerous undefined behavior."),(0,r.kt)("h2",{id:"dispose"},"Dispose"),(0,r.kt)("p",null,"Every such ",(0,r.kt)("inlineCode",{parentName:"p"},"RustAutoOpaque")," object has a ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose()")," method,\nwhich immediately frees the underlying resource\n(tech details if you are worried: indeed decrease the reference count, so dispose-when-use is no problem).\nBut even if you do not call it,\nwhen Dart does garbage collection (GC),\nthe same thing will be automatically triggered."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose")," method mimics the standard pattern in Flutter -\nwe have ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"ui.Image"),", etc."),(0,r.kt)("p",null,"Should we call ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose")," manually?\nThis is discussed thoroughly in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/sdk/issues/54233"},"this thread"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/native/issues/848"},"this related thread"),".\nFor full information, please refer to those posts directly.\nIn short, thanks to @dcharkes @dnfield @HosseinYousefi @lrhn @mkustermann (ordered alphabetically),\nwhen your underlying Rust objects are huge or takes precious resources (e.g. opens a file),\ndo manual ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose")," to ensure you release the resource as soon as you do not need them;\notherwise, there is usually no worry about manual dispose calls."),(0,r.kt)("h2",{id:"force-a-non-opaque-type-to-be-opaque"},"Force a non-opaque type to be opaque"),(0,r.kt)("p",null,"If a type is indeed encodable, it will by default be translated to the corresponding Dart types.\nHowever, if you want to force it to be opaque, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[frb(opaque)]")," attribute."),(0,r.kt)("p",null,"This is useful, for example, when the data is heavy and is mainly used in Rust,\nand you do not want to transfer it between Dart and Rust over and over again."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct A { name: String }\n\n#[frb(opaque)]\nstruct B { name: String }\n")),(0,r.kt)("p",null,"Will generate different Dart code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// A pretty standard Dart class with fields inside it\nclass A { String name; ... }\n\n// A Dart class without data fields, you should pass it to Rust to manipulate it\nclass B extends RustAutoOpaque {}\n")),(0,r.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,r.kt)("p",null,"As for how it is implemented as well as the design towards safety,\nplease refer to ",(0,r.kt)("a",{parentName:"p",href:"../../contributing/submodules/rust-opaque"},"this doc")))}d.isMDXComponent=!0}}]);